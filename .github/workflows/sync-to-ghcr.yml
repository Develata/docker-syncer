name: 04. 单项同步 (To GHCR)
env:
  WEBHOOK_URL: ${{ secrets.WEBHOOK_URL }}
  REGISTRY: ghcr.io
  # 映射 Secret 到 Env 以供 if 判断
  DOCKERHUB_USER: ${{ secrets.DOCKERHUB_USERNAME }}

on:
  workflow_dispatch:
    inputs:
      image_name:
        description: "原镜像名称 (例如: mysql:8.0)"
        required: true
        default: "nginx:alpine"
      target_name:
        description: "保存名称 (留空则自动处理)"
        required: false
      platform:
        description: "指定架构 (例如: linux/arm64，留空默认 amd64)"
        required: false
        default: ""
      force_sync:
        description: "强制同步 (跳过摘要比对)"
        type: boolean
        required: false
        default: false
      clean_disk:
        description: "清理磁盘空间 (减少空间不足风险，但耗时增加)"
        type: boolean
        required: false
        default: false

jobs:
  mirror:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write # 必须权限

    steps:
      # 🔥 关键修复：先 Checkout 代码，才能读取 config.env
      - name: Checkout 代码
        uses: actions/checkout@v4

      - name: 读取 config.env 配置
        id: config
        run: |
          if [ -f "config.env" ]; then
            echo "读取 config.env 配置..."
            source config.env
            echo "CLEAN_DISK_SPACE=$CLEAN_DISK_SPACE" >> $GITHUB_ENV
            echo "✅ 配置加载成功 (CLEAN_DISK_SPACE=$CLEAN_DISK_SPACE)"
          else
            echo "⚠️ 未找到 config.env，使用默认配置"
            echo "CLEAN_DISK_SPACE=${{ inputs.clean_disk }}" >> $GITHUB_ENV
          fi

      # 🔧 Skopeo 依赖检查
      - name: 检查和安装 Skopeo
        run: |
          if ! command -v skopeo &> /dev/null; then
            echo "Skopeo not found, installing..."
            sudo apt-get update && sudo apt-get install -y skopeo
          else
            echo "✅ Skopeo 已安装: $(skopeo --version)"
          fi

      # 1. 空间清理 (防止大镜像爆盘)
      - name: 🗑️ 清理磁盘空间
        uses: easimon/maximize-build-space@master
        if: env.CLEAN_DISK_SPACE == 'true'
        with:
          root-reserve-mb: 2048
          swap-size-mb: 128
          remove-dotnet: "true"
          remove-android: "true"
          remove-haskell: "true"
          build-mount-path: "/var/lib/docker/"

      - name: 重启 Docker
        run: sudo service docker restart

      - name: 登录 DockerHub
        if: env.DOCKERHUB_USER != ''
        uses: docker/login-action@v2
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}
        continue-on-error: true

      - name: 登录 GHCR
        uses: docker/login-action@v2
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: 拉取、重命名并推送
        env:
          INPUT_IMAGE: ${{ inputs.image_name }}
          INPUT_TARGET: ${{ inputs.target_name }}
          INPUT_PLATFORM: ${{ inputs.platform }}
          INPUT_FORCE: ${{ inputs.force_sync }}
        run: |
          # Define retry function
          # Define retry function
          function retry {
            local n=1
            local max=3
            local delay=5
            while true; do
              "$@" && break || {
                if [[ $n -lt $max ]]; then
                  ((n++))
                  echo "⚠️ Command failed. Attempt $n/$max:" >&2
                  sleep $delay;
                else
                  echo "❌ The command has failed after $max attempts." >&2
                  return 1
                fi
              }
            done
          }

          # --- 1. 变量准备 ---
          SRC_IMAGE="$INPUT_IMAGE"
          PLATFORM_ARG=""

          # 默认架构参数
          SKOPEO_OS="linux"
          SKOPEO_ARCH="amd64"

          if [ -n "$INPUT_PLATFORM" ]; then
            PLATFORM_ARG="--platform $INPUT_PLATFORM"
            echo "⚙️ 指定架构: $INPUT_PLATFORM"
            
            # 解析 platform
            if [[ "$INPUT_PLATFORM" == *"/"* ]]; then
               SKOPEO_OS=$(echo "$INPUT_PLATFORM" | awk -F'/' '{print $1}')
               SKOPEO_ARCH=$(echo "$INPUT_PLATFORM" | awk -F'/' '{print $2}')
            else
               SKOPEO_ARCH="$INPUT_PLATFORM"
            fi
          fi

          # 构造 Skopeo 参数
          SKOPEO_FLAGS="--override-os $SKOPEO_OS --override-arch $SKOPEO_ARCH"

          # --- 2. 目标名称计算 (智能前缀) ---
          # 📄 改进：添加 registry 域名前缀以避免命名冲突
          if [ -n "$INPUT_TARGET" ]; then
            TARGET_TAG="$INPUT_TARGET"
          else
             REGISTRY_PREFIX=""
             SCOPE=""
             IMAGE_PATH="$SRC_IMAGE"
             
             # 提取 registry 域名（如果存在）
             # 支持带端口号的私有Registry：192.168.1.100:5000 → 192-168-1-100-5000
             if [[ "$SRC_IMAGE" == *"."*"/"* ]] || [[ "$SRC_IMAGE" == *":"*"/"* ]]; then
                 # 包含域名，如 quay.io/coreos/etcd 或 192.168.1.100:5000/my-app
                 REGISTRY_PREFIX=$(echo "$SRC_IMAGE" | cut -d'/' -f1 | sed 's/[\.]/-/g' | sed 's/:/-/g')
                 IMAGE_PATH=$(echo "$SRC_IMAGE" | cut -d'/' -f2-)
             fi
             
             BASE_NAME=$(basename "$IMAGE_PATH" | cut -d':' -f1)
             TAG_NAME=$(echo "$IMAGE_PATH" | cut -d':' -f2 -s)
             [ -z "$TAG_NAME" ] && TAG_NAME="latest"
             
             # 解析 namespace
             if [[ "$IMAGE_PATH" == *"/"* ]]; then
                 NAMESPACE_PART=$(dirname "$IMAGE_PATH")
                 if [[ "$NAMESPACE_PART" != "library" && "$NAMESPACE_PART" != "." ]]; then
                    SCOPE=$(basename "$NAMESPACE_PART")
                 fi
             fi
             
             # 组合命名：[registry_][scope_]basename:tag
             if [ -n "$REGISTRY_PREFIX" ] && [ -n "$SCOPE" ]; then
                TARGET_TAG="${REGISTRY_PREFIX}_${SCOPE}_${BASE_NAME}:${TAG_NAME}"
             elif [ -n "$REGISTRY_PREFIX" ]; then
                TARGET_TAG="${REGISTRY_PREFIX}_${BASE_NAME}:${TAG_NAME}"
             elif [ -n "$SCOPE" ]; then
                TARGET_TAG="${SCOPE}_${BASE_NAME}:${TAG_NAME}"
             else
                TARGET_TAG="${BASE_NAME}:${TAG_NAME}"
             fi
             
             # 多架构前缀追加
             if [ -n "$INPUT_PLATFORM" ]; then
                PLAT_PREFIX=$(echo "$INPUT_PLATFORM" | sed 's/\//_/g')
                TARGET_TAG="${PLAT_PREFIX}_${TARGET_TAG}"
             fi
          fi

          # --- 3. GHCR 强制转小写 ---
          OWNER=$(echo "${{ github.repository_owner }}" | tr '[:upper:]' '[:lower:]')
          TARGET_TAG=$(echo "$TARGET_TAG" | tr '[:upper:]' '[:lower:]')
          FULL_TARGET="${{ env.REGISTRY }}/$OWNER/$TARGET_TAG"

          echo "🎯 目标镜像地址: $FULL_TARGET"

          # --- 4. 智能摘要比对 ---
          NEED_SYNC=true
          if [ "$INPUT_FORCE" == "false" ]; then
             echo "🔍 检查 Digest & Created..."
             SRC_INFO=$(retry skopeo inspect $SKOPEO_FLAGS "docker://$SRC_IMAGE" --format='{{.Digest}}|{{.Created}}' 2>/dev/null || echo "")
             SRC_DIGEST=$(echo "$SRC_INFO" | cut -d'|' -f1)
             SRC_CREATED=$(echo "$SRC_INFO" | cut -d'|' -f2)
             
             DEST_INFO=$(retry skopeo inspect $SKOPEO_FLAGS "docker://$FULL_TARGET" --format='{{.Digest}}|{{.Created}}' 2>/dev/null || echo "")
             DEST_DIGEST=$(echo "$DEST_INFO" | cut -d'|' -f1)
             DEST_CREATED=$(echo "$DEST_INFO" | cut -d'|' -f2)
             
             if [ -n "$SRC_DIGEST" ]; then
                 if [ "$SRC_DIGEST" == "$DEST_DIGEST" ]; then
                    echo "✅ 摘要一致 ($SRC_DIGEST)，无需同步。"
                    NEED_SYNC=false
                 elif [ -n "$DEST_DIGEST" ] && [ "$SRC_CREATED" == "$DEST_CREATED" ]; then
                    echo "⚠️ 摘要不同但创建时间一致 ($SRC_CREATED)，判定为同源，跳过。"
                    NEED_SYNC=false
                 else
                     echo "🚀 需同步: $SRC_DIGEST vs $DEST_DIGEST"
                 fi
             else
                 echo "⚠️ 无法获取源摘要，跳过。"
                 NEED_SYNC=false
             fi
          fi

          # --- 5. 执行同步 ---
          if [ "$NEED_SYNC" == "true" ]; then
             echo "📥 拉取: $SRC_IMAGE"
             retry docker pull "$SRC_IMAGE" $PLATFORM_ARG

             echo "🏷️ 打标签: $FULL_TARGET"
             docker tag "$SRC_IMAGE" "$FULL_TARGET"

             echo "📤 推送: $FULL_TARGET"
             retry docker push "$FULL_TARGET"
             
             echo "🧹 清理..."
             docker rmi "$SRC_IMAGE" "$FULL_TARGET" || true

             echo "✅ 完成! docker pull $FULL_TARGET"
          fi

      - name: 发送 Webhook 通知
        if: always()
        run: |
          if [ -z "$WEBHOOK_URL" ]; then
            exit 0
          fi

          if [ "${{ job.status }}" == "success" ]; then
             TITLE="✅ GHCR 同步成功"
          else
             TITLE="❌ GHCR 同步失败"
          fi

          PAYLOAD=$(cat <<EOF
          {
            "msg_type": "text",
            "content": {
              "text": "$TITLE\n镜像: ${{ inputs.image_name }}\n状态: ${{ job.status }}\n链接: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}"
            }
          }
          EOF
          )

          curl -H "Content-Type: application/json" -d "$PAYLOAD" "$WEBHOOK_URL" || true
